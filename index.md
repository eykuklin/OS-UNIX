<img src="img/head.png" width="100%">

### Задания для самостоятельной работы по курсу
# Операционная система UNIX

## Предисловие

Готовые задачи принимаются в виде ссылок на репозиторий на GitHub.

Основной язык программирования: C. Во всех программах разбор параметров делать через библиотеку getopt. Сборка программы должна осуществляться через make. Для сборки, запуска и тестирования должен использоваться скрипт с именем runme.sh, который при необходимости может вызывать вспомогательные скрипты.

Каждый системный вызов должен проверяться на корректность выполнения. В случае критических ошибок программа должна завершаться с информативным сообщением. Отчет о работе тестов должен сохраняться в файл result.txt и должен содержать краткое описание тестов с описанием ожидаемого результата и вывод фактических результатов тестов.

Временные рамки:
- **ФИИТ-4.** В связи с ранней сессией, для допуска к зачёту достаточно одной любой задачи, присланной до конца апреля. Для сдачи зачёта автоматом: три задачи до конца апреля.
- **КБ** (КН и остальные). Каждая задача имеет свой дедлайн. Для допуска к зачёту - две любые задачи. Для сдачи зачёта автоматом: четыре сделанные вовремя задачи. 

## Задача 1

**Тема: работа с файлами - open, read, write, seek.**

Sparse file — файл, в котором последовательности нулевых байтов заменены на информацию о них. Последовательность нулевых байт внутри файла (дыры) не записывается на диск, а информация о них (смещение от начала файла в байтах и количество байт) хранится в метаданных ФС. Сжатие архиваторами типа gzip происходит очень эффективно. При распаковке всё наоборот: gzip не заботится о создании дырок и забивает их нулями с риском выйти за пределы файловой системы.

Требуется написать программу создания sparse файлов. Программа считает нули и заменяет блоки, заполненные нулями, на seek для создания разреженного файла. Поскольку запись в файл идёт поблочно, то и входные данные надо обрабатывать поблочно (бессмысленно записать 1 байт, потом сделать seek на 315 байт и записать ещё один байт - все уйдет в один блок). По умолчанию сделать размер блока 4096 байт, но отдельный параметр должен задавать размер блока в байтах.

Если на вход программе подаётся один аргумент — имя файла, то читается stdin и пишется в указанный файл. Если два аргумента, то читается первый файл и пишется в последний.

Также написать вспомогательный скрипт, создающий тестовый файл A, длиной 4\*1024\*1024 + 1 байт, заполненный в основном нулями. По смещениям 0, 10000 и в конце файла должны быть записаны единицы.

Далее в runme.sh прописываются следующие действия:

0. Создать файл A.
1. Скопировать созданный файл A через нашу программу в файл B, сделав его разреженным:<br/>
`$ ./myprogram fileA fileB`
2. Сжать A и B с помощью gzip.
3. Распаковать сжатый файл B в stdout и сохранить через программу в файл C:<br/>
`$ gzip -cd fileB.gz | ./myprogram fileC`
4. Скопировать A через программу в файл D, указав нестандартный размер блока - 100 байт.
5. Программой stat вывести реальный размер файлов A, A.gz, B, B.gz, C, D

Ключевые функции: read(), write(), lseek(output, count, SEEK_CUR), ftruncate(output, size).

**Срок:** до 18.04 включительно.


## Задача 2

**Тема:  совместная работа с файлами, понятие блокировок.**

Представим, что мы работаем в примитивной файловой системе без каких-либо файловых блокировок типа flock. Требуется сделать собственную программу для файловых блокировок на основе создания файлов \<myfile\>.lck, где \<myfile\> — имя блокируемого файла.

Алгоритм работы:
0. Получить из аргументов командной строки имя файла myfile.
1. Проверить существование файла .lck: если не существует, то создать; если существует, то ожидать его удаления.
2. Записать в этот файл свой pid.
3. Выполнить чтение/запись исходного файла myfile, добавить сон для наглядности.
4. Проверить, что файл .lck ещё существует и в нём записан свой pid. Если это так, то удалить файл, если нет — завершиться с сообщением об ошибке.

Убедиться, что программа ломается на снятии блокировки: сделать скрипт, который будет запускать программу блокировки, а потом удалять/портить lck файл.

Написать в runme.sh тестовый скрипт, который запустит в параллель 10 задач, каждая из которых в бесконечном цикле блокирует общий файл на 1 секунду, а потом снимает блокировку. Писать или читать общий файл не обязательно. Через пять минут завершить все десять задач сигналом sigint. В задачах вести статистику количества успешных блокировок. По сигналу sigint задача должна сохранить статистику блокировок в общий файл статистики и завершиться. Убедиться, что задачи не падают из-за порчи lck файла (гонки). Убедиться, что файл статистики содержит по одной строке на каждую задачу. Убедиться, что статистика блокировок для всех процессов примерно одинакова (нет тупиков).

**Срок:** до 02.05 включительно.


## Задача 3

**Тема: родительские и дочерние процессы, демоны, сигналы.**

В некоторых Unix первым запущенным пользовательским процессом является init, который после своей загрузки запускает остальные необходимые для жизни системы процессы. Требуется написать программу myinit, представляющую собой упрощенный вариант init, которая запускает другие программы и следит за их состоянием. От myinit требуется: чтение конфигурационного файла с программами, запуск дочерних процессов, демонизация своего процесса, реагирование на kill -hup.

При старте программе myinit указывается конфигурационный файл, который состоит из строк, содержащие следующие поля: путь к исполняемому файлу с его ключами, файл для перенаправления stdin, файл для перенаправления stdout:

`/bin/sleep 15 /home/user/myinit1/in /home/user/myinit1/out`

После запуска myinit меняет текущий каталог на корневой, закрывает все файлы, избавляется от управляющего терминала, открывает лог-файл в каталоге /tmp, затем читает конфигурационный файл и запускает по одному дочернему процессу на каждую строку. В дочернем процессе перенаправляет ввод вывод и запускает указанный исполняемый файл. **Attention:** необходимо проверять, что все пути абсолютные, иначе при смене текущего каталога в корень ФС всё порушится. Информация о запущеных процессах пишется в лог. При завершении любого из дочерних процессов — стартовать аналогичный, запустив программу из той же строки конфигурационного файла, что и завершившаяся. Причину завершения и новый старт записать в лог.

По сигналу sighup заново открыть конфигурационный файл, завершить все текущие процессы, стартовать новые. Все данные о завершении процессов и старте новых записать в лог.

Написать в runme.sh тестовый скрипт, который стартует через myinit 3 тестовых процесса с разными именами. Проверить командой ps что запущено три дочерних процесса. Командой pkill убить процесс номер 2. Через секунду проверить командой ps, что снова запущено три дочерних процесса. Заменить конфигурационный файл на файл для выполнения одного дочернего процесса. Отправить myinit сигнал sighup. Проверить командой ps, что запущен только один дочерний процесc. Проверить в log файле, что выполнились ожидаемые действия: старт трёх процессов, завершение и рестарт процесса номер 2, завершение трёх процессов, старт одного процесса.

Файл шаблона для слежения за потомками <a href="fork_waitpid.c">прилагается</a>. Пример шаблона для создания демона есть в книге Робачевского (2е издание стр. 211).

Ключевые функции: fork(), exec(), waitpid(), signal().

**Срок:** до 16.05 включительно.


## Задача 4

**Тема: сокеты, асинхронный ввод-вывод.**

Требутся реализовать клиент-серверную архитектуру со свойствами ниже.

Серверная программа "броуновский бот" имеет некоторое внутреннее состояние, представленное целым числом; при старте это ноль. Программа создает серверный UNIX сокет потока в каталоге /tmp. Имя сокета прописано в файле config. Клиент читает из config имя сокета и подключается к нему. После подключения клиент читает с stdin положительные и отрицательные числа в виде строк не длиннее 10 символов и отправляет их на сервер. Строки разделяются символом \n. Сервер читает строки, конвертирует их в числа и складывает с числом состояния; полученный результат отправляет в виде строки назад. Для отладки сервер пишет в лог последовательность полученных строк и возвращенных ответов.

Однопоточный сервер должен уметь буферизовать ввод данных от клиентов и с помощью select или poll асинхронно считывать данные от многих клиентов. Сервер должен корректно отрабатывать ситуацию, когда кто-то из клиентов приостанавливается на середине строки - это не должно приводить к зависанию сервера.

Проверка работоспособности написанных программ включает в себя следующее:
1. Написать скрипт, который запустит параллельно 100 тестовых клиентов, каждый из которых будет читать файл (один на всех) со 1000 числами. Сумма всех чисел в файле равна нулю. Тестовый клиент должен содержать код, который читает из файла побайтово и случайно в интервале 1-255 байтов вставляет задержку в несколько долей секунды. Поскольку сумма всех чисел равна нулю, то после завершения всех клиентов внутреннее состояние сервера должно быть равно нулю. Это проверяется отправкой с клиента числа ноль и получения ответа ноль.
2. Проверить, что сервер корректно работает без перезапуска при повторных выполнениях тестового скрипта. (Опционально) проверить, что длительное выполнение сервера с последовательными подключениями/отключениями тестовых клиентов не приводят к существенному увеличению объёма памяти, используемой сервером, и числа занятых файловых дескрипторов. Для этого, при подключении нового клиента сохранять в лог номер использованного для подключения файлового дескриптора и значение указателя на границу кучи sbrk(). В результат выдать из лога первую и последнюю запись такого типа.
3. Сделать время задержки параметром. В каждом клиенте подсчитать суммарное время задержек и сохранить по завершению работы в файле. Написать скрипт, который на основе логов сервера и логов клиентов будет показывать эффективную скорость работы сервера в зависимости от задержек и числа клиентов. Критерием эффективности считать время от первого запроса клиента до последнего минус время суммы задержек у самого "медленного" клиента. Поскольку сервер практически не выполняет вычислений, а объём передаваемых данных мал, то при корректной реализации асинхронности время работы сервера должно быть практически равно времени выполнения самого "медленного" клиента. Провести несколько экспериментов с разным числом клиентов от 1 до 100 и задержками от 0 до 1 с шагом 0.2 секунды.

Связать всё описанное в одном runme.sh для получения готовой статистики по трем пунктам.

**Срок:** до 31.05 (или до дня зачёта).
