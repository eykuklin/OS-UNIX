//Шаблон программы-демона

#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/param.h>
#include <sys/resource.h>

int main(int argc, char **argv)
{
    int fd;
    struct rlimit flim;
    char *log_file = "/tmp/myinit.log";
    char *message = "myinit started\n";

 /* Если родительский процесс — init, можно не беспокоиться
    за терминальные сигналы. Если нет — необходимо игнорировать
    сигналы, связанные с вводом/выводом на терминал
    фонового процесса: SIGTTOU, SIGTTIN, SIGTSTP */

    if (getppid() != 1)
    {
        signal(SIGTTOU, SIG_IGN);
        signal(SIGTTIN, SIG_IGN);
        signal(SIGTSTP, SIG_IGN);

 /* Теперь необходимо организовать собственную группу и сеанс,
    не имеющие управляющего терминала. Однако лидером группы и
    сеанса может стать процесс, если он еще не является лидером.
    Поскольку предыстория запуска данной программы неизвестна,
    необходима гарантия, что наш процесс не является лидером.
    Для этого порождаем дочерний процесс. Т.к. его PID уникален,
    то ни группы, ни сеанса с таким идентификатором не существует,
    а значит нет и лидера. При этом родительский процесс
    немедленно завершает выполнение, поскольку он уже не нужен.
    Существует еще одна причина необходимости порождения
    дочернего процесса. Если демон был запущен из командной строки
    командного интерпретатора shell не в фоновом режиме,
    последний будет ожидать завершения выполнения демона,
    и таким образом, терминал будет заблокирован.
    Порождая процесс и завершая выполнение родителя,
    имитируем для командного интерпретатора завершение
    работы демона, после чего shell выведет свое приглашение */

        if (fork () !=0)
        exit(0); /* Родитель заканчивает работу */

   /* Дочерний процесс с помощью системного вызова
      становится лидером новой группы, сеанса и не имеет
      ассоциированного терминала */
        
        setsid();
    }

 /* Теперь необходимо закрыть открытые файлы. Закроем
    все возможные файловые дескрипторы. Максимальное число
    открытых файлов получим с помощью функции getrlimit */

    getrlimit(RLIMIT_NOFILE, &flim);
    for (fd = 0; fd < flim.rlim_max; fd++) close(fd);

 /* Сменим текущий каталог на корневой */

    if (chdir("/") != 0) return 1;

 /* Откроем дескриптор лог-файла и создадим запись */

    fd = open(log_file, O_CREAT | O_TRUNC | O_WRONLY, 0600);
    write(fd, message, strlen(message));
    close(fd);

 /* Далее следует текст программы, реализующий полезные функции
    демона */

}
